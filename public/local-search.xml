<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Limitation of Java Lambdas</title>
    <link href="/blog/2023/09/07/java-function/"/>
    <url>/blog/2023/09/07/java-function/</url>
    
    <content type="html"><![CDATA[<p>“First-class citizen” function means a function can be dynamically created and be passed around just like any other value. Java 8 added lambda expression that provide  “similar” feature by simplifying the creation of anonymous classes.</p><h1 id="Java-Lambdas"><a href="#Java-Lambdas" class="headerlink" title="Java Lambdas"></a>Java Lambdas</h1><p>Compared to other languages like JavaScript, Python, and C++, Java lambda expressions come with several limitations:</p><ul><li><strong>You can’t use bound variables</strong> (e.g., captured variables in C++ or upvalues in Lua) unless they are declared as <code>final</code>. Therefore, it’s not easy to make closure or higher-order functions.</li><li><strong>You can’t throw checked exceptions</strong>, unless the caller explicitly allows.</li></ul><p>As lambda expressions are compiled as instantiating an anonymous class, apparently the compiler needs to figure out the name of the interface (of the anonymous class), and that interface must have exactly one abstract method. This leads to the most annoying limitation of Java lambdas: <strong>Lambda expression must have an explicit target-type of <code>FunctionalInterface</code></strong>. </p><p>In other languages, you can easily create an anonymous generic function.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Python</span><br>add = <span class="hljs-keyword">lambda</span> x, y: x + y <br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># returns 3</span><br>add(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>) <span class="hljs-comment"># returns 3.0</span><br>add(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment"># returns &#x27;ab&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y;<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) # returns <span class="hljs-number">3</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>) # returns <span class="hljs-number">3.0</span><br><span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) # returns <span class="hljs-string">&#x27;ab&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++14</span><br><span class="hljs-keyword">auto</span> add = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)&#123; <span class="hljs-keyword">return</span> x + y;&#125;;<br><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// returns int(3) </span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>) <span class="hljs-comment">// returns double(3.0)</span><br><span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;foo&quot;</span>s, <span class="hljs-string">&quot;bar&quot;</span>s); <span class="hljs-comment">// returns string(&quot;foobar&quot;)</span><br></code></pre></td></tr></table></figure><p>But in Java you simply can’t do so. <strong>Compiler is unable to infer the type of lambda expression</strong>. It must be specified during declaration. This is probably the only case where a value is not convertible to <code>Object</code>, even <code>var</code> does not work here.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> (x,y) -&gt; x + y; <br><span class="hljs-comment">// error: incompatible types: Object is not a functional interface</span><br><br><span class="hljs-type">var</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> (x,y) -&gt; x + y;<br><span class="hljs-comment">// error: cannot infer type for local variable add</span><br></code></pre></td></tr></table></figure><p>Users have to associate lambda expression with the correct interface so as to inform the compiler the number and types of the arguments and the type of the return value. Standard library kindly provides a few frequently-used <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">functional interfaces</a> to pick from.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BiFunction&lt;Integer, Integer, Integer&gt; addInteger = (x,y) -&gt; x+y;<br>BiFunction&lt;String, String, String&gt; addString = (x,y) -&gt; x+y; <br></code></pre></td></tr></table></figure><p><strong>You have to enumerate all arguments for lambda types not in the standard library</strong>. For example, to represents a function that accepts four arguments and produces one result, you have to declare the corresponding interface first.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">QuadFunction</span> &lt;T1, T2, T3, T4, R&gt; &#123;<br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T1 t1, T2 t2, T3 t3, T4 t4)</span>;<br>&#125;;<br><br>QuadFunction&lt;String, String, String, String, String&gt; qf = (a,b,c,d)-&gt;a+b+c+d;<br></code></pre></td></tr></table></figure><p>Just think how tedious it could be when there are many arguments.</p><p>On the other hand, <strong>it is a compile-error to convert a lambda into a different functional interface</strong>, even if they represent the same function. For example, a function taking one integer and returning a boolean, can be represented as<br><code>Function&lt;Integer, Boolean&gt;</code> or <code>Predicate&lt;Integer&gt;</code>. But unfortunately these two types are not compatible with each other, because they have different names of their abstract methods.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Boolean&gt; isZero = x -&gt; x != <span class="hljs-number">0</span>;<br>Predicate&lt;Integer&gt; isZero2 = isZero; <br><span class="hljs-comment">// error: incompatible types: Function&lt;Integer,Boolean&gt; cannot be converted to Predicate&lt;Integer&gt;</span><br><br>Supplier&lt;Child&gt; makeObject = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>Supplier&lt;Parent&gt; makeObject2 = makeObject;<br><span class="hljs-comment">// error: incompatible types: Supplier&lt;Child&gt; cannot be converted to Supplier&lt;Parent&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="Defined-Interfaces-in-java-util-function"><a href="#Defined-Interfaces-in-java-util-function" class="headerlink" title="Defined Interfaces in java.util.function"></a>Defined Interfaces in <code>java.util.function</code></h1><table><thead><tr><th>Signature</th><th>Name</th><th>Method</th><th>Comment</th></tr></thead><tbody><tr><td><code>T      -&gt; R</code></td><td><code>Function&lt;T, R&gt;</code></td><td><code>apply</code></td><td></td></tr><tr><td><code>()     -&gt; R</code></td><td><code>Supplier&lt;R&gt;</code></td><td><code>get</code></td><td></td></tr><tr><td><code>T      -&gt; boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>test</code></td><td></td></tr><tr><td><code>T      -&gt; Void</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>accept</code></td><td></td></tr><tr><td><code>T      -&gt; T</code></td><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>apply</code></td><td></td></tr><tr><td><code>(T, U) -&gt; R</code></td><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>apply</code></td><td></td></tr><tr><td><code>(T, U) -&gt; boolean</code></td><td><code>BiPredicate&lt;T, U&gt;</code></td><td><code>test</code></td><td></td></tr><tr><td><code>(T, U) -&gt; Void</code></td><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>apply</code></td><td></td></tr><tr><td><code>(T, T) -&gt; T</code></td><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>apply</code></td><td></td></tr><tr><td><code>()     -&gt; Void</code></td><td><code>Runnable</code></td><td><code>run</code></td><td>in <code>java.lang</code></td></tr></tbody></table><h1 id="Custom-functional-interfaces"><a href="#Custom-functional-interfaces" class="headerlink" title="Custom functional interfaces"></a>Custom functional interfaces</h1><p>A functional interface must have <em>exactly one</em> non-overriding abstract method.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">X1</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">X2</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">number</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">X3</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>; <span class="hljs-comment">// This means X3 supertype already has a default implementation</span><br>&#125;;<br><br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">X4</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Apply <code>java.lang.FunctionalInterface</code> annotation so that compiler could check if the interface meets the criteria.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">X5</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>;<br>&#125; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">|  Error:</span><br><span class="hljs-comment">|  Unexpected @FunctionalInterface annotation</span><br><span class="hljs-comment">|    X5 is not a functional interface</span><br><span class="hljs-comment">|      multiple non-overriding abstract methods found in interface X5</span><br><span class="hljs-comment">|  @FunctionalInterface</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
