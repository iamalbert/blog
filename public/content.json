{"meta":{"title":"Albert's Blog","subtitle":"隨筆","description":"","author":"Wenlih Chuang","url":"https://iamalbert.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"Limitation of Java Lambdas","slug":"java-function","date":"2023-09-07T22:42:06.000Z","updated":"2023-11-12T03:36:30.629Z","comments":true,"path":"2023/09/07/java-function/","permalink":"https://iamalbert.github.io/blog/2023/09/07/java-function/","excerpt":"","text":"“First-class citizen” function means a function can be dynamically created and be passed around just like any other value. Java 8 added lambda expression that provide “similar” feature by simplifying the creation of anonymous classes. Compared to other languages like JavaScript, Python, and C++, Java lambda expressions come with several limitations: You can’t use bound variables (e.g., captured variables in C++ or upvalues in Lua) unless they are declared as final. Therefore, it’s not easy to make closure or higher-order functions. You can’t throw checked exceptions, unless the caller explicitly allows. However, because a lambda expression is compiled as instantiating an anonymous class, it’s obvious that the compiler needs to figure out the name of the class, and that class must have exactly one abstract method. This leads to the most annoying limitation of Java lambdas: Lambda expression must have an explicit target-type of FunctionalInterface. In other languages you can easily create an generic anonymous function. 123456# Pythonadd = lambda x, y: x + y add(1, 2) # returns 3add(1.0, 2.0) # returns 3.0add(&#x27;a&#x27;, &#x27;b&#x27;) # returns &#x27;ab&#x27; 12345const add = (x, y) =&gt; x + y;add(1, 2) # returns 3add(1.0, 2.0) # returns 3.0add(&#x27;a&#x27;, &#x27;b&#x27;) # returns &#x27;ab&#x27; 123456// C++14auto add = [](auto x, auto y)&#123; return x + y;&#125;;add(1, 2); // returns int(3) add(1.0, 2.0) // returns double(3.0)add(&quot;foo&quot;s, &quot;bar&quot;s); // returns string(&quot;foobar&quot;) But in Java you simply can’t do so. Compiler is unable to infer the type of lambda expression, which must be specified during declaration. This is the only case where a value is not convertible to Object, even var does not work. 12345Object add = (x,y) -&gt; x + y; // error: incompatible types: Object is not a functional interfacevar add = (x,y) -&gt; x + y;// error: cannot infer type for local variable add You have to tell the compiler the number and types of arguments, and the type of the return value by using the correct class. standard library has kindly provide the most frequently-used functional interfaces. 12BiFunction&lt;Integer, Integer, Integer&gt; addInteger = (x,y) -&gt; x+y;BiFunction&lt;String, String, String&gt; addString = (x,y) -&gt; x+y; You have to enumerate all arguments for lambda types not in the standard library. For example, to represents a function that accepts four arguments and produces a result, you have to declare the corresponding interface first. 12345public interface QuadFunction &lt;T1, T2, T3, T4, R&gt; &#123; R apply(T1 t1, T2 t2, T3 t3, T4 t4);&#125;;QuadFunction&lt;String, String, String, String, String&gt; qf = (a,b,c,d)-&gt;a+b+c+d; Just think how tedious it could be when there are many arguments. On the other hand, it is a compile-error to convert a lambda into a different functional interface, even if they represent the same function. For example, a function taking one integer and returning a boolean, can be represented asFunction&lt;Integer, Boolean&gt; or Predicate&lt;Integer&gt; but unfortunately these two types are not compatible with each other, because they have different abstract method names. 1234Function&lt;Integer, Boolean&gt; isZero = x -&gt; x != 0;Predicate&lt;Integer&gt; isZero2 = isZero; // error: incompatible types: Function&lt;Integer,Boolean&gt; cannot be converted to Predicate&lt;Integer&gt; Defined Interfaces in java.util.function Signature Name Method Comment T -&gt; R Function&lt;T, R&gt; apply () -&gt; R Supplier&lt;R&gt; get T -&gt; boolean Predicate&lt;T&gt; test T -&gt; Void Consumer&lt;T&gt; accept T -&gt; T UnaryOperator&lt;T&gt; apply (T, U) -&gt; R BiFunction&lt;T, U, R&gt; apply (T, U) -&gt; boolean BiPredicate&lt;T, U&gt; test (T, U) -&gt; Void BiConsumer&lt;T, U&gt; apply (T, T) -&gt; T BinaryOperator&lt;T&gt; apply () -&gt; Void Runnable run in java.lang Custom functional interfacesA functional interface must have exactly one non-overriding abstract method. 12345678910111213141516171819202122232425public interface X1 &#123; void func();&#125;;public interface X2 &#123; void func(); int number()&#123; return 1; &#125;&#125;;@FunctionalInterfacepublic interface X3 &#123; void func(); @Override String toString(); // This means X3 supertype already has a default implementation&#125;;@FunctionalInterfacepublic interface X4 &#123; void func();&#125; Apply java.lang.FunctionalInterface annotation so that compiler could check if the interface meets the criteria. 123456789101112@FunctionalInterfacepublic interface X5 &#123; void func1(); void func2();&#125; /*| Error:| Unexpected @FunctionalInterface annotation| X5 is not a functional interface| multiple non-overriding abstract methods found in interface X5| @FunctionalInterface*/","categories":[{"name":"programming","slug":"programming","permalink":"https://iamalbert.github.io/blog/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"https://iamalbert.github.io/blog/tags/java/"}]}],"categories":[{"name":"programming","slug":"programming","permalink":"https://iamalbert.github.io/blog/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"https://iamalbert.github.io/blog/tags/java/"}]}